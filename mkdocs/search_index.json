{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the hamopy documentation\n\n\nHamopy is a python package for the numerical simulation of one-dimensional heat, air and moisture (HAM) transfer in porous materials. Its principle is the finite-element resolution of the HAM conservation equations. The only requirement to run it is a fairly recent version of SciPy.\n\n\nThe original field of application is the hygrothermal modelling of building materials, although the code is not restricted to it.\n\n\nHamopy makes good use of its open-source nature, and gives users complete control over the simulation process. One can:\n\n\n\n\nadd new materials and customise the equations defining their properties,\n\n\naccount for water flow and storage in both liquid and vapor states,\n\n\ninclude time-dependent boundary conditions,\n\n\nwork with fully coupled hygrothermal transfer, or with thermal transfer only (saves time),\n\n\neasily automate many simulations for sensitivity analyses, evolutionary algorithms and such.\n\n\n\n\nAny contribution into improving hamopy is welcome, as to make open-source HAM modelling available and understandable by all.\n\n\nInstallation\n\n\nYou can download and install hamopy by cloning the \nGitHub repository\n, or download and unpack the ZIP file.\n\n\nThen include the path to the download directory to your PATH or PYTHONPATH environment variable.\n\n\nHow things work\n\n\nOnce \nhamopy\n is detected by your Python installation, this is basically how a simulation is run:\n\n\nfrom hamopy.algorithm import calcul\nresults = calcul(mesh, clim, init, time)\n\n\n\nThe first line imports the main algorithm of hamopy, the second line runs the simulation under specified conditions (the \nmesh\n, \nclim\n, \ninit\n and \ntime\n objects) and stores \nresults\n as a python dictionary.\n\n\nOf course, some questions remain unanswered, which is what this page is for.\n\n\nUser guide\n\n\n\n\nInputs\n: how to define the conditions of simulation\n\n\nMaterials\n: how to create a new material\n\n\nBoundary conditions\n: how to set up boundary conditions\n\n\n\n\n\n\nSimulation\n: some options to customise and monitor the simulation\n\n\nLibrary\n: small library of useful functions within hamopy\n\n\n\n\n\n\nPost-processing\n: how to visualise results\n\n\n\n\nExamples\n\n\n\n\nHamstad BM 3\n: 3rd benchmark exercise of the Hamstad package\n\n\nHamstad BM 5\n: 5th benchmark exercise of the Hamstad package",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-the-hamopy-documentation",
            "text": "Hamopy is a python package for the numerical simulation of one-dimensional heat, air and moisture (HAM) transfer in porous materials. Its principle is the finite-element resolution of the HAM conservation equations. The only requirement to run it is a fairly recent version of SciPy.  The original field of application is the hygrothermal modelling of building materials, although the code is not restricted to it.  Hamopy makes good use of its open-source nature, and gives users complete control over the simulation process. One can:   add new materials and customise the equations defining their properties,  account for water flow and storage in both liquid and vapor states,  include time-dependent boundary conditions,  work with fully coupled hygrothermal transfer, or with thermal transfer only (saves time),  easily automate many simulations for sensitivity analyses, evolutionary algorithms and such.   Any contribution into improving hamopy is welcome, as to make open-source HAM modelling available and understandable by all.",
            "title": "Welcome to the hamopy documentation"
        },
        {
            "location": "/#installation",
            "text": "You can download and install hamopy by cloning the  GitHub repository , or download and unpack the ZIP file.  Then include the path to the download directory to your PATH or PYTHONPATH environment variable.",
            "title": "Installation"
        },
        {
            "location": "/#how-things-work",
            "text": "Once  hamopy  is detected by your Python installation, this is basically how a simulation is run:  from hamopy.algorithm import calcul\nresults = calcul(mesh, clim, init, time)  The first line imports the main algorithm of hamopy, the second line runs the simulation under specified conditions (the  mesh ,  clim ,  init  and  time  objects) and stores  results  as a python dictionary.  Of course, some questions remain unanswered, which is what this page is for.",
            "title": "How things work"
        },
        {
            "location": "/#user-guide",
            "text": "Inputs : how to define the conditions of simulation  Materials : how to create a new material  Boundary conditions : how to set up boundary conditions    Simulation : some options to customise and monitor the simulation  Library : small library of useful functions within hamopy    Post-processing : how to visualise results",
            "title": "User guide"
        },
        {
            "location": "/#examples",
            "text": "Hamstad BM 3 : 3rd benchmark exercise of the Hamstad package  Hamstad BM 5 : 5th benchmark exercise of the Hamstad package",
            "title": "Examples"
        },
        {
            "location": "/user-guide/inputs/",
            "text": "Input definition\n\n\nThe hamopy algorithm is called like so:\n\n\nfrom hamopy.algorithm import calcul\nresults = calcul(mesh, clim, init, time)\n\n\n\nThis means that all inputs of the simulation are contained within 4 objects that serve as arguments for the \ncalcul\n method:\n\n\n\n\nmesh\n contains all information regarding the material definition and spatial discretisation of the domain\n\n\nclim\n stores boundary conditions\n\n\ninit\n defines the initialisation of the domain\n\n\ntime\n specifies the time of simulation, time step size, etc.\n\n\n\n\nBelow is the syntax for the definition of these objects.\n\n\nmesh: material definition and discretisation\n\n\nThe \nmesh\n argument is created by instantiating a new object of the \nhamopy.classes.Mesh\n class.\n\n\nfrom hamopy.classes import Mesh\nfrom hamopy.materials.standard import wood_fibre\n\nmesh = Mesh(materials    = [wood_fibre],\n            sizes        = [0.08],\n            nbr_elements = [16] )\n\n\n\nThe example above imports the wood fibre board from the \nhamopy.materials.standard\n material library. Then, it creates a wall of thickness 0.08 m, discretised with 16 finite elements.\n\n\nHere is an example of a multi-layered wall:\n\n\nfrom hamopy.classes import Mesh\nfrom hamopy.materials.standard import concrete, wood_fibre\n\nmesh = Mesh(materials    = [concrete, wood_fibre],\n            sizes        = [0.10, 0.08],\n            nbr_elements = [24, 16] )\n\n\n\nFrom left to right, this example creates a wall with a 10 cm concrete layer divided into 24 finite elements, and an 8 cm wood fibre layer with 16 finite elements.\n\n\nThe instantiation of the \nMesh\n class always takes 3 arguments: \nmaterials\n, \nsizes\n and \nnbr_elements\n. These arguments are \nalways lists\n, even when only one layer is involved as in the first example.\n\n\nMaterials must be imported before the mesh is created. They are objects of the \nMaterial\n class: the \nmaterials\n page of this site shows how to define one.\n\n\nclim: boundary conditions\n\n\nThe \nclim\n argument sent to the simulation is a list of two objects of the \nBoundary\n class.\n\n\nfrom hamopy.classes import Boundary\n\nclim_01 = Boundary('Dirichlet',**{\"T\"  : 293.15,\n                                  \"HR\" : 0.7 })\n\nclim_02 = Boundary('Fourier',**{\"T\"   : 278.15,\n                                \"HR\"  : 0.9,\n                                \"h_t\" : 5 })\n\nclim = [clim_01, clim_02]\n\n\n\nTwo boundaries are created separately and stored in the \nclim\n list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)].\n\n\nThe instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data.\n\n\nThe example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...) The \nboundary conditions\n page shows how to do all that.\n\n\ninit: initialisation\n\n\nThe \ninit\n object is simply a dictionary containing the initial value of the temperature under the \n'T'\n key, and of the relative humidity under the \n'HR'\n key:\n\n\ninit = {'T'  : 293.15,\n        'HR' : 0.95}\n\n\n\nAlternatively, the relative humidity can be replaced by a value of vapor pressure with the \n'PV'\n key or of capillary pressure with the \n'PC'\n key.\n\n\nIt is possible to define non-uniform initial conditions, by adding an \n'x'\n key to the dictionary:\n\n\ninit = {'x'  : [0, 0.05, 0.10],\n        'T'  : [273, 287, 291],\n        'HR' : [0.7, 0.4, 0.6] }\n\n\n\nIn this example, the initial conditions will be a linear interpolation of the values given at the coordinates 0, 0.05, and 0.10 m.\n\n\ntime: temporal discretisation\n\n\nThe object storing information on the discretisation in time is an occurence of the \nTime\n class. Its instantiation resembles that of the \nBoundary\n object:\n\n\nfrom hamopy.classes import Time\ntime = Time('constant',**{\"delta_t\" : 600,\n                          \"t_max\"   : 7200 } )\n\n\n\nThe definition of the \ntime\n requires two input arguments: a string indicating whether the time step size should be constant or variable, and a dictionary containing numerical data. In the example above, it is declared that the time step size \ndelta_t\n is 600 seconds, and that the simulation time \nt_max\n is 7200 seconds.\n\n\nIt is possible to ask for the time step size to automatically adapt to eventual convergence difficulties. This is done by setting the method string to \n'variable'\n, and optionnaly adding some keys to the dictionary:\n\n\n\n\n'iter_max'\n: maximum number of iterations in a time step (default is 12)\n\n\n'delta_min'\n: minimum time step size (default is 1e-3)\n\n\n'delta_max'\n: maximum time step size (default is 900)\n\n\n\n\nOnce all 4 objects are defined, you can start the \nsimulation\n.\n\n\nDocumentation main page",
            "title": "Input definition"
        },
        {
            "location": "/user-guide/inputs/#input-definition",
            "text": "The hamopy algorithm is called like so:  from hamopy.algorithm import calcul\nresults = calcul(mesh, clim, init, time)  This means that all inputs of the simulation are contained within 4 objects that serve as arguments for the  calcul  method:   mesh  contains all information regarding the material definition and spatial discretisation of the domain  clim  stores boundary conditions  init  defines the initialisation of the domain  time  specifies the time of simulation, time step size, etc.   Below is the syntax for the definition of these objects.",
            "title": "Input definition"
        },
        {
            "location": "/user-guide/inputs/#mesh-material-definition-and-discretisation",
            "text": "The  mesh  argument is created by instantiating a new object of the  hamopy.classes.Mesh  class.  from hamopy.classes import Mesh\nfrom hamopy.materials.standard import wood_fibre\n\nmesh = Mesh(materials    = [wood_fibre],\n            sizes        = [0.08],\n            nbr_elements = [16] )  The example above imports the wood fibre board from the  hamopy.materials.standard  material library. Then, it creates a wall of thickness 0.08 m, discretised with 16 finite elements.  Here is an example of a multi-layered wall:  from hamopy.classes import Mesh\nfrom hamopy.materials.standard import concrete, wood_fibre\n\nmesh = Mesh(materials    = [concrete, wood_fibre],\n            sizes        = [0.10, 0.08],\n            nbr_elements = [24, 16] )  From left to right, this example creates a wall with a 10 cm concrete layer divided into 24 finite elements, and an 8 cm wood fibre layer with 16 finite elements.  The instantiation of the  Mesh  class always takes 3 arguments:  materials ,  sizes  and  nbr_elements . These arguments are  always lists , even when only one layer is involved as in the first example.  Materials must be imported before the mesh is created. They are objects of the  Material  class: the  materials  page of this site shows how to define one.",
            "title": "mesh: material definition and discretisation"
        },
        {
            "location": "/user-guide/inputs/#clim-boundary-conditions",
            "text": "The  clim  argument sent to the simulation is a list of two objects of the  Boundary  class.  from hamopy.classes import Boundary\n\nclim_01 = Boundary('Dirichlet',**{\"T\"  : 293.15,\n                                  \"HR\" : 0.7 })\n\nclim_02 = Boundary('Fourier',**{\"T\"   : 278.15,\n                                \"HR\"  : 0.9,\n                                \"h_t\" : 5 })\n\nclim = [clim_01, clim_02]  Two boundaries are created separately and stored in the  clim  list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)].  The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data.  The example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...) The  boundary conditions  page shows how to do all that.",
            "title": "clim: boundary conditions"
        },
        {
            "location": "/user-guide/inputs/#init-initialisation",
            "text": "The  init  object is simply a dictionary containing the initial value of the temperature under the  'T'  key, and of the relative humidity under the  'HR'  key:  init = {'T'  : 293.15,\n        'HR' : 0.95}  Alternatively, the relative humidity can be replaced by a value of vapor pressure with the  'PV'  key or of capillary pressure with the  'PC'  key.  It is possible to define non-uniform initial conditions, by adding an  'x'  key to the dictionary:  init = {'x'  : [0, 0.05, 0.10],\n        'T'  : [273, 287, 291],\n        'HR' : [0.7, 0.4, 0.6] }  In this example, the initial conditions will be a linear interpolation of the values given at the coordinates 0, 0.05, and 0.10 m.",
            "title": "init: initialisation"
        },
        {
            "location": "/user-guide/inputs/#time-temporal-discretisation",
            "text": "The object storing information on the discretisation in time is an occurence of the  Time  class. Its instantiation resembles that of the  Boundary  object:  from hamopy.classes import Time\ntime = Time('constant',**{\"delta_t\" : 600,\n                          \"t_max\"   : 7200 } )  The definition of the  time  requires two input arguments: a string indicating whether the time step size should be constant or variable, and a dictionary containing numerical data. In the example above, it is declared that the time step size  delta_t  is 600 seconds, and that the simulation time  t_max  is 7200 seconds.  It is possible to ask for the time step size to automatically adapt to eventual convergence difficulties. This is done by setting the method string to  'variable' , and optionnaly adding some keys to the dictionary:   'iter_max' : maximum number of iterations in a time step (default is 12)  'delta_min' : minimum time step size (default is 1e-3)  'delta_max' : maximum time step size (default is 900)   Once all 4 objects are defined, you can start the  simulation .  Documentation main page",
            "title": "time: temporal discretisation"
        },
        {
            "location": "/user-guide/materials/",
            "text": "Creating materials\n\n\nAs shown on the \ninput definition\n page, creating the \nmesh\n object for the simulation requires including a material object in the arguments of the \nMesh\n instantiation.\n\n\nfrom hamopy.classes import Mesh\nfrom hamopy.materials.standard import wood_fibre\n\nmesh = Mesh(materials = [wood_fibre],\n        sizes     = [0.08],\n        nbr_elem  = [16] )\n\n\n\nThis means that the \nhamopy\\materials\\standard.py\n file contains the definition of an object called \nwood_fibre\n, which is of the \nMaterial\n class and includes all material data.\n\n\nMaterial definition in hamopy is a bit tricky, as it was designed to give the user maximum freedom for defining fully customisable transport properties.\n\n\nThis page tells you how to\n\n\n\n\ndefine a new material,\n\n\nuse its properties once they have been registered,\n\n\nmodify a material in an existing mesh.\n\n\n\n\nMaterial definition\n\n\nInstantiation\n\n\nFor purposes of reusability, the definition of a new material should preferably be done in a separate file which you can then import into your script (like \nhamopy.materials.standard\n above)\n\n\nOnce there, you may start by instantiating a new \nMaterial\n object:\n\n\nfrom hamopy.classes import Material\n\nconcrete = Material('concrete', rho = 2400., cp = 880.)\n\n\n\nThe instantiation may take up to three arguments: the material name, its dry density (kg/m3) and specific heat (J/(kg.K)).\n\n\nOnce created, the \nMaterial\n object contains the following set of methods to register all material properties.\n\n\nset_density()\n\n\nIf not provided at the instantiation, you can specify the dry density of the material like so:\n\n\nconcrete.set_density(2430.)\n\n\n\nset_capacity()\n\n\nIn the current state of hamopy, the heat capacity (J/(kg.K)) of the dry material can be defined as a function of the temperature.\n\n\nconcrete.set_capacity(cp_0 = 2430., cp_t = 27.)\n\n\n\nWhen called, the value of the heat capacity will then be \ncp = cp_0 + T(\u00b0C) * cp_t\n\n\nThe default value for \ncp_t\n is 0.\n\n\nset_conduc()\n\n\nThe thermal conductivity (W/(m.K)) may be defined as a function of the moisture content and temperature.\n\n\nconcrete.set_conduc(lambda_0 = 1.75, lambda_m = 4.5, lambda_t = 1e-4)\n\n\n\nWhen called, the value of the conductivity will then be \nlambda = lambda_0 + w(kg/m3)/1000 * lambda_m + T(\u00b0C) * lambda_t\n\n\nThe default value for \nlambda_m\n and \nlambda_t\n is 0.\n\n\nset_isotherm()\n\n\nThere are currently two methods for defining the sorption isotherm:\n\n\nEither a 3rd degree polynomial interpolation, fitted on a list of measurement points:\n\n\nwood_fibre.set_isotherm('polynomial', **{\"HR\" : [0, 0.25, 0.5, 0.75],\n                                 \"W\"  : [0, 6.2, 12.4, 20.9] })\n\n\n\nwhere the list given in the \n'W'\n key are the values of the moisture content measured at the relative humidities \n'HR'\n.\n\n\nThe second method for defining the sorption isotherm is the van Genuchten mono- or multimodal law:\n\n\nlightweight.set_isotherm('vangenuchten', **{\"w_sat\" : 871,\n                                        \"l\"     : [0.41, 0.59],\n                                        \"alpha\" : [6.12e-7, 1.22e-6],\n                                        \"m\"     : [0.5981, 0.5816] })\n\n\n\nset_perm_vapor()\n\n\nThere are currently two methods for defining the water vapor permeability:\n\n\nEither by interpolation between measurement points:\n\n\nconcrete.set_perm_vapor('interp', **{\"HR\" : [0.25, 0.75],\n                                 \"dp\" : [4.2e-12, 7.8e-12] } )\n\n\n\nOt with the Schirmer law:\n\n\nlightweight.set_perm_vapor('schirmer', **{\"mu\" : 5.6,\n                                      \"p\"  : 0.2 })\n\n\n\nset_perm_liquid()\n\n\nThere are currently two methods for defining the liquid permeability:\n\n\nEither with an exponential law:\n\n\nlightweight.set_perm_liquid('exp', **{\"a\" : [-46.245, 294.506, -1439, 3249, -3370, 1305] } )\n\n\n\nOr with the Durner multi-modal law:\n\n\nconcrete.set_perm_liquid('durner', **{\"K_sat\" : 2.2182e-13,\n                                  \"tau\"   : -4.6974,\n                                  \"l\"     : [0.5062, 0.4938],\n                                  \"alpha\" : [5.5383e-7, 2.2493e-8],\n                                  \"m\"     : [0.6148, 0.1913] } )\n\n\n\nNote that if this method is not used in the definition of a material, this permeability will be set to \n0\n and liquid transfer will not be considered in the calculation.\n\n\nset_perm_air()\n\n\nThe air permeability should be given in (m^2^). Only a constant value is expected:\n\n\nlightweight.set_perm_air(1.08e-10)\n\n\n\nCalling this method is optional: the default air permeability is \n0\n.\n\n\nCalling properties\n\n\nOnce defined, all properties may be called as fonctions of the temperature \nT\n and capillary pressure \np_c\n. The following methods are bound within the \nMaterial\n class for this purpose\n\n\n\n\nmaterial.rho(T)\n: density\n\n\nmaterial.cp(T)\n: heat capacity\n\n\nmaterial.conduc(p_c, T)\n: heat conductivity (\np_c\n and \nT\n are optional arguments)\n\n\nmaterial.w(p_c)\n: moisture content (kg/m3)\n\n\nmaterial.c_v(p_c)\n: moisture capacity (derivative of the moisture content)\n\n\nmaterial.delta_p(p_c, T)\n: vapour permeability (\nT\n is an optional argument)\n\n\nmaterial.k_l(p_c, T)\n: liquid permeability (\nT\n is an optional argument)\n\n\nmaterial.k_air()\n: air permeability\n\n\n\n\nImportant\n: hamopy is written with the capillary pressure as the driving potential for moisture transfer. All variables depending on the humidity are therefore methods expecting \np_c\n as input argument, rather than the value of relative humidity or vapor pressure. Some functions are however available in the \nlibrary\n to easily switch from one another.\n\n\nSwitch materials\n\n\nOnce a material has been integrated into a \nMesh\n object, it is still possible to change some of its properties and tell the mesh of the modifications:\n\n\nfrom hamopy.materials.standard import concrete, wood_fibre\nfrom copy import deepcopy\n\nmesh = Mesh(**{\"materials\"    : [concrete, wood_fibre],\n           \"sizes\"        : [0.1, 0.08],\n           \"nbr_elements\" : [16, 12] })\n\nwood_fibre_2 = deepcopy(wood_fibre)\nwood_fibre_2.set_density(170.)\n\nmesh.replace_materials([concrete, wood_fibre_2])\n\n\n\nThis functionality is particularly interesting when running a large number of simulations with different material properties, like in case of a sensitivity analysis. The instantiation of the \nMesh\n and \nMaterial\n objects is not repeated, which saves some time.\n\n\nDocumentation main page",
            "title": "Materials"
        },
        {
            "location": "/user-guide/materials/#creating-materials",
            "text": "As shown on the  input definition  page, creating the  mesh  object for the simulation requires including a material object in the arguments of the  Mesh  instantiation.  from hamopy.classes import Mesh\nfrom hamopy.materials.standard import wood_fibre\n\nmesh = Mesh(materials = [wood_fibre],\n        sizes     = [0.08],\n        nbr_elem  = [16] )  This means that the  hamopy\\materials\\standard.py  file contains the definition of an object called  wood_fibre , which is of the  Material  class and includes all material data.  Material definition in hamopy is a bit tricky, as it was designed to give the user maximum freedom for defining fully customisable transport properties.  This page tells you how to   define a new material,  use its properties once they have been registered,  modify a material in an existing mesh.",
            "title": "Creating materials"
        },
        {
            "location": "/user-guide/materials/#material-definition",
            "text": "",
            "title": "Material definition"
        },
        {
            "location": "/user-guide/materials/#instantiation",
            "text": "For purposes of reusability, the definition of a new material should preferably be done in a separate file which you can then import into your script (like  hamopy.materials.standard  above)  Once there, you may start by instantiating a new  Material  object:  from hamopy.classes import Material\n\nconcrete = Material('concrete', rho = 2400., cp = 880.)  The instantiation may take up to three arguments: the material name, its dry density (kg/m3) and specific heat (J/(kg.K)).  Once created, the  Material  object contains the following set of methods to register all material properties.",
            "title": "Instantiation"
        },
        {
            "location": "/user-guide/materials/#set_density",
            "text": "If not provided at the instantiation, you can specify the dry density of the material like so:  concrete.set_density(2430.)",
            "title": "set_density()"
        },
        {
            "location": "/user-guide/materials/#set_capacity",
            "text": "In the current state of hamopy, the heat capacity (J/(kg.K)) of the dry material can be defined as a function of the temperature.  concrete.set_capacity(cp_0 = 2430., cp_t = 27.)  When called, the value of the heat capacity will then be  cp = cp_0 + T(\u00b0C) * cp_t  The default value for  cp_t  is 0.",
            "title": "set_capacity()"
        },
        {
            "location": "/user-guide/materials/#set_conduc",
            "text": "The thermal conductivity (W/(m.K)) may be defined as a function of the moisture content and temperature.  concrete.set_conduc(lambda_0 = 1.75, lambda_m = 4.5, lambda_t = 1e-4)  When called, the value of the conductivity will then be  lambda = lambda_0 + w(kg/m3)/1000 * lambda_m + T(\u00b0C) * lambda_t  The default value for  lambda_m  and  lambda_t  is 0.",
            "title": "set_conduc()"
        },
        {
            "location": "/user-guide/materials/#set_isotherm",
            "text": "There are currently two methods for defining the sorption isotherm:  Either a 3rd degree polynomial interpolation, fitted on a list of measurement points:  wood_fibre.set_isotherm('polynomial', **{\"HR\" : [0, 0.25, 0.5, 0.75],\n                                 \"W\"  : [0, 6.2, 12.4, 20.9] })  where the list given in the  'W'  key are the values of the moisture content measured at the relative humidities  'HR' .  The second method for defining the sorption isotherm is the van Genuchten mono- or multimodal law:  lightweight.set_isotherm('vangenuchten', **{\"w_sat\" : 871,\n                                        \"l\"     : [0.41, 0.59],\n                                        \"alpha\" : [6.12e-7, 1.22e-6],\n                                        \"m\"     : [0.5981, 0.5816] })",
            "title": "set_isotherm()"
        },
        {
            "location": "/user-guide/materials/#set_perm_vapor",
            "text": "There are currently two methods for defining the water vapor permeability:  Either by interpolation between measurement points:  concrete.set_perm_vapor('interp', **{\"HR\" : [0.25, 0.75],\n                                 \"dp\" : [4.2e-12, 7.8e-12] } )  Ot with the Schirmer law:  lightweight.set_perm_vapor('schirmer', **{\"mu\" : 5.6,\n                                      \"p\"  : 0.2 })",
            "title": "set_perm_vapor()"
        },
        {
            "location": "/user-guide/materials/#set_perm_liquid",
            "text": "There are currently two methods for defining the liquid permeability:  Either with an exponential law:  lightweight.set_perm_liquid('exp', **{\"a\" : [-46.245, 294.506, -1439, 3249, -3370, 1305] } )  Or with the Durner multi-modal law:  concrete.set_perm_liquid('durner', **{\"K_sat\" : 2.2182e-13,\n                                  \"tau\"   : -4.6974,\n                                  \"l\"     : [0.5062, 0.4938],\n                                  \"alpha\" : [5.5383e-7, 2.2493e-8],\n                                  \"m\"     : [0.6148, 0.1913] } )  Note that if this method is not used in the definition of a material, this permeability will be set to  0  and liquid transfer will not be considered in the calculation.",
            "title": "set_perm_liquid()"
        },
        {
            "location": "/user-guide/materials/#set_perm_air",
            "text": "The air permeability should be given in (m^2^). Only a constant value is expected:  lightweight.set_perm_air(1.08e-10)  Calling this method is optional: the default air permeability is  0 .",
            "title": "set_perm_air()"
        },
        {
            "location": "/user-guide/materials/#calling-properties",
            "text": "Once defined, all properties may be called as fonctions of the temperature  T  and capillary pressure  p_c . The following methods are bound within the  Material  class for this purpose   material.rho(T) : density  material.cp(T) : heat capacity  material.conduc(p_c, T) : heat conductivity ( p_c  and  T  are optional arguments)  material.w(p_c) : moisture content (kg/m3)  material.c_v(p_c) : moisture capacity (derivative of the moisture content)  material.delta_p(p_c, T) : vapour permeability ( T  is an optional argument)  material.k_l(p_c, T) : liquid permeability ( T  is an optional argument)  material.k_air() : air permeability   Important : hamopy is written with the capillary pressure as the driving potential for moisture transfer. All variables depending on the humidity are therefore methods expecting  p_c  as input argument, rather than the value of relative humidity or vapor pressure. Some functions are however available in the  library  to easily switch from one another.",
            "title": "Calling properties"
        },
        {
            "location": "/user-guide/materials/#switch-materials",
            "text": "Once a material has been integrated into a  Mesh  object, it is still possible to change some of its properties and tell the mesh of the modifications:  from hamopy.materials.standard import concrete, wood_fibre\nfrom copy import deepcopy\n\nmesh = Mesh(**{\"materials\"    : [concrete, wood_fibre],\n           \"sizes\"        : [0.1, 0.08],\n           \"nbr_elements\" : [16, 12] })\n\nwood_fibre_2 = deepcopy(wood_fibre)\nwood_fibre_2.set_density(170.)\n\nmesh.replace_materials([concrete, wood_fibre_2])  This functionality is particularly interesting when running a large number of simulations with different material properties, like in case of a sensitivity analysis. The instantiation of the  Mesh  and  Material  objects is not repeated, which saves some time.  Documentation main page",
            "title": "Switch materials"
        },
        {
            "location": "/user-guide/boundary/",
            "text": "Boundary conditions\n\n\nConstant conditions\n\n\nThe \nclim\n argument sent to the simulation is a list of two objects of the \nBoundary\n class. The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data. The \ninput definition\n page shows a simple example of how boundary conditions can be defined:\n\n\nfrom hamopy.classes import Boundary\n\nclim_01 = Boundary('Dirichlet',**{\"T\"  : 293.15,\n                              \"HR\" : 0.7 })\n\nclim_02 = Boundary('Fourier',**{\"T\"   : 278.15,\n                            \"HR\"  : 0.9,\n                            \"h_t\" : 5 })\n\nclim = [clim_01, clim_02]\n\n\n\nTwo boundaries are created separately and stored in the \nclim\n list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)].\n\n\nVariable conditions\n\n\nThe example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...)\n\n\nLet's say one of your boundaries has a variable temperature and air pressure, which are stored in a .txt file \nwith headers\n. In this case, this is how you instantiate a new boundary with the second column as the temperature and the third column as the air pressure:\n\n\nclim_file = 'path_to_your_file/file_name.txt'\n\nclim_01 = Boundary('Fourier',**{\"file\"  : clim_file,\n                            \"time\"  : \"Time (s)\",\n                            \"T\"     : \"Temp. (K)\",\n                            \"P_air\" : \"Air pressure\",\n                            \"HR\"    : 0.7,\n                            \"h_t\"   : 10,\n                            \"h_m\"   : 2e-7 })\n\n\n\nwhere \"Time (s)\", \"Temp. (K)\" and \"Air pressure\" are headers of the text file, on top of each variable of interest.\n\n\nA boundary can be assigned both constant and variable values at the same time:\n\n\n\n\nIf a key of the dictionary points to a string (like \n'T'\n and \n'P_air'\n above), then \nBoundary\n will attempt to read it under the corresponding header in the .txt file.\n\n\nIf a key points to a numerical value (like \n'HR'\n, \n'h_t'\n and \n'h_m'\n above), \nBoundary\n will keep it constant during the entire simulation time.\n\n\n\n\nIf any boundary value varies, the dictionary \nmust\n contain a \n'file'\n key pointing to the file location on your drive, and a \n'time'\n key pointing to the column containing time coordinates. Note that you can use a single file to store data for both of your domain boundaries, like so:\n\n\nclim_file = 'path_to_your_file/file_name.txt'\n\nclim_01 = Boundary('Fourier',**{\"file\"  : clim_file,\n                            \"time\"  : \"Time (s)\",\n                            \"T\"     : \"Temp. (K)\",\n                            \"P_air\" : \"Air pressure\",\n                            \"HR\"    : 0.7,\n                            \"h_t\"   : 10,\n                            \"h_m\"   : 2e-7 })\n\nclim_02 = Boundary('Dirichlet',**{\"file\" : clim_file,\n                             \"time\"  : \"Time (s)\",\n                             \"T\"     : \"Temp. 2 (K)\",\n                             \"HR\"    : 0.85 })\n\nclim = [clim_01, clim_02]\n\n\n\nThis formulation aims at giving maximum flexibility for the definition of the boundary conditions.\n\n\nKeys\n\n\nThe dictionary which you give as argument for the instantiation of a new \n'Boundary'\n object may specify more content than in the examples above. The following is a list of the keys that may (or should) be included in it.\n\n\n\n\n'T'\n: temperature in \u00b0C or K\n\n\n'HR'\n: relative humidity (dimensionless)\n\n\n'p_v'\n: water vapor pressure (Pa), only needed if HR is not given\n\n\n'h_t'\n: surface heat transfer coefficient (W/(m2.K)). Optional, default value is 5 W/(m2.K)\n\n\n'h_m'\n: surface moisture transfer coefficient (s/m). Optional, default is \n7.45e-9 * h_t\n\n\n'T_eq'\n: equivalent temperature, accounting for effects of solar radiation. Optional, it is set equal to \n'T'\n if not given.\n\n\n'g_l'\n: liquid water income caused by rain (kg/(m2.s)). Optional, default value is zero\n\n\n'P_air'\n: air pressure (Pa), impacting eventual air transfer in the wall. Optional, default value is zero\n\n\n\n\nAny of these values can either be constant, or read from a .txt file. In this case, these additional keys should be given in the dictionary:\n\n\n\n\n'file'\n: file location on the hard drive\n\n\n'delimiter'\n: delimiter used in the text file. Default is tab.\n\n\n'time'\n: location of the time data in the text file\n\n\n\n\nDocumentation main page",
            "title": "Boundary conditions"
        },
        {
            "location": "/user-guide/boundary/#boundary-conditions",
            "text": "",
            "title": "Boundary conditions"
        },
        {
            "location": "/user-guide/boundary/#constant-conditions",
            "text": "The  clim  argument sent to the simulation is a list of two objects of the  Boundary  class. The instantiation of a boundary requires two arguments: a string to specify the boundary type, and a dictionary to specify numerical data. The  input definition  page shows a simple example of how boundary conditions can be defined:  from hamopy.classes import Boundary\n\nclim_01 = Boundary('Dirichlet',**{\"T\"  : 293.15,\n                              \"HR\" : 0.7 })\n\nclim_02 = Boundary('Fourier',**{\"T\"   : 278.15,\n                            \"HR\"  : 0.9,\n                            \"h_t\" : 5 })\n\nclim = [clim_01, clim_02]  Two boundaries are created separately and stored in the  clim  list. The first one is a constant type one (Dirichlet) condition of 293.15 K and 0.7 relative humidity. The second one is a type three (Fourier) conditions with a surface transfer coefficient of 5 [W/(m2K)].",
            "title": "Constant conditions"
        },
        {
            "location": "/user-guide/boundary/#variable-conditions",
            "text": "The example above is very simple, but things can get a little more complicated: boundary conditions can be variable in time and more parameters can be specified (air pressure, surface transfer coefficients...)  Let's say one of your boundaries has a variable temperature and air pressure, which are stored in a .txt file  with headers . In this case, this is how you instantiate a new boundary with the second column as the temperature and the third column as the air pressure:  clim_file = 'path_to_your_file/file_name.txt'\n\nclim_01 = Boundary('Fourier',**{\"file\"  : clim_file,\n                            \"time\"  : \"Time (s)\",\n                            \"T\"     : \"Temp. (K)\",\n                            \"P_air\" : \"Air pressure\",\n                            \"HR\"    : 0.7,\n                            \"h_t\"   : 10,\n                            \"h_m\"   : 2e-7 })  where \"Time (s)\", \"Temp. (K)\" and \"Air pressure\" are headers of the text file, on top of each variable of interest.  A boundary can be assigned both constant and variable values at the same time:   If a key of the dictionary points to a string (like  'T'  and  'P_air'  above), then  Boundary  will attempt to read it under the corresponding header in the .txt file.  If a key points to a numerical value (like  'HR' ,  'h_t'  and  'h_m'  above),  Boundary  will keep it constant during the entire simulation time.   If any boundary value varies, the dictionary  must  contain a  'file'  key pointing to the file location on your drive, and a  'time'  key pointing to the column containing time coordinates. Note that you can use a single file to store data for both of your domain boundaries, like so:  clim_file = 'path_to_your_file/file_name.txt'\n\nclim_01 = Boundary('Fourier',**{\"file\"  : clim_file,\n                            \"time\"  : \"Time (s)\",\n                            \"T\"     : \"Temp. (K)\",\n                            \"P_air\" : \"Air pressure\",\n                            \"HR\"    : 0.7,\n                            \"h_t\"   : 10,\n                            \"h_m\"   : 2e-7 })\n\nclim_02 = Boundary('Dirichlet',**{\"file\" : clim_file,\n                             \"time\"  : \"Time (s)\",\n                             \"T\"     : \"Temp. 2 (K)\",\n                             \"HR\"    : 0.85 })\n\nclim = [clim_01, clim_02]  This formulation aims at giving maximum flexibility for the definition of the boundary conditions.",
            "title": "Variable conditions"
        },
        {
            "location": "/user-guide/boundary/#keys",
            "text": "The dictionary which you give as argument for the instantiation of a new  'Boundary'  object may specify more content than in the examples above. The following is a list of the keys that may (or should) be included in it.   'T' : temperature in \u00b0C or K  'HR' : relative humidity (dimensionless)  'p_v' : water vapor pressure (Pa), only needed if HR is not given  'h_t' : surface heat transfer coefficient (W/(m2.K)). Optional, default value is 5 W/(m2.K)  'h_m' : surface moisture transfer coefficient (s/m). Optional, default is  7.45e-9 * h_t  'T_eq' : equivalent temperature, accounting for effects of solar radiation. Optional, it is set equal to  'T'  if not given.  'g_l' : liquid water income caused by rain (kg/(m2.s)). Optional, default value is zero  'P_air' : air pressure (Pa), impacting eventual air transfer in the wall. Optional, default value is zero   Any of these values can either be constant, or read from a .txt file. In this case, these additional keys should be given in the dictionary:   'file' : file location on the hard drive  'delimiter' : delimiter used in the text file. Default is tab.  'time' : location of the time data in the text file   Documentation main page",
            "title": "Keys"
        },
        {
            "location": "/user-guide/simulation/",
            "text": "Running a simulation\n\n\nLet's say you have correctly defined all conditions of the simulation by reading \nthis helpful page\n. All you need to do now is import the main algorithm and run it\n\n\nfrom hamopy.algorithm import calcul\n\nresults = calcul(mesh, clim, init, time)\n\n\n\nThe rest is \npost-processing\n.\n\n\nOptions\n\n\nThe syntax for calling the simulation may be slightly modified for three purposes: choosing the type of output, keeping a record of the simulation process, or simulate thermal transfer only.\n\n\nOutput type\n\n\nThe \ncalcul()\n method normally returns a dictionary storing all necessary data for \npost-processing\n. Another available option is to save this data into a file in the uncompressed .npz format\n\n\nfrom hamopy.algorithm import calcul\n\ncalcul(mesh, clim, init, time, output_type = 'file')\n\n\n\nThis will create a file called \nhamopy_output.npz\n in the working directory. This method of output selection can be customised by modifying the \nalgorithm\n module.\n\n\nDiary\n\n\nShould you encounter convergence difficulties, you may want the algorithm to store its progress somewhere so you may locate the problems. The \ncalcul()\n method may take an additional argument for this purpose:\n\n\nfrom hamopy.algorithm import calcul\n\ndiary = 'file_name'\n\nresults = calcul(mesh, clim, init, time, logfile = diary)\n\n\n\nThis will create a file at the specified location, on which the record of the convergence criteria will be saved.\n\n\nHeat transfer only\n\n\nThe code is initially designed for coupled heat and moisture transfer, but the user may want to skip the humidity and only calculate heat. This is done through an alternate version of the algorithm:\n\n\nfrom hamopy.algorithm import calcul_thermo\n\nresults = calcul_thermo(mesh, clim, init, time)\n\n\n\nThis should run about 4 times faster than coupled heat and mass transfer.\n\n\nDocumentation main page",
            "title": "Simulation"
        },
        {
            "location": "/user-guide/simulation/#running-a-simulation",
            "text": "Let's say you have correctly defined all conditions of the simulation by reading  this helpful page . All you need to do now is import the main algorithm and run it  from hamopy.algorithm import calcul\n\nresults = calcul(mesh, clim, init, time)  The rest is  post-processing .",
            "title": "Running a simulation"
        },
        {
            "location": "/user-guide/simulation/#options",
            "text": "The syntax for calling the simulation may be slightly modified for three purposes: choosing the type of output, keeping a record of the simulation process, or simulate thermal transfer only.",
            "title": "Options"
        },
        {
            "location": "/user-guide/simulation/#output-type",
            "text": "The  calcul()  method normally returns a dictionary storing all necessary data for  post-processing . Another available option is to save this data into a file in the uncompressed .npz format  from hamopy.algorithm import calcul\n\ncalcul(mesh, clim, init, time, output_type = 'file')  This will create a file called  hamopy_output.npz  in the working directory. This method of output selection can be customised by modifying the  algorithm  module.",
            "title": "Output type"
        },
        {
            "location": "/user-guide/simulation/#diary",
            "text": "Should you encounter convergence difficulties, you may want the algorithm to store its progress somewhere so you may locate the problems. The  calcul()  method may take an additional argument for this purpose:  from hamopy.algorithm import calcul\n\ndiary = 'file_name'\n\nresults = calcul(mesh, clim, init, time, logfile = diary)  This will create a file at the specified location, on which the record of the convergence criteria will be saved.",
            "title": "Diary"
        },
        {
            "location": "/user-guide/simulation/#heat-transfer-only",
            "text": "The code is initially designed for coupled heat and moisture transfer, but the user may want to skip the humidity and only calculate heat. This is done through an alternate version of the algorithm:  from hamopy.algorithm import calcul_thermo\n\nresults = calcul_thermo(mesh, clim, init, time)  This should run about 4 times faster than coupled heat and mass transfer.  Documentation main page",
            "title": "Heat transfer only"
        },
        {
            "location": "/user-guide/library/",
            "text": "Library of functions\n\n\nAll material-independant values, universal constants and state equations are stored within the \nhamopy/ham_library\n file. In addition to constant properties such as the latent heat of evaporation, the universal gas constant and the thermal conductivity of air, the file includes 5 useful methods:\n\n\n\n\np_sat(T)\n: Water vapor saturation pressure (Pa)\n\n\nD_va(T)\n: Water vapor diffusivity in air (m2/s)\n\n\np_v(p_c, T)\n: Water vapor pressure (Pa)\n\n\nHR(p_c, T)\n: Relative humidity\n\n\np_c(HR, T)\n: Capillary pressure (Pa)\n\n\n\n\nThe last three methods are equivalent formulations of the Clausius-Clapeyron equation. It is used to calculate the relative humidity from values of the capillary pressure, and inversely.\n\n\nHere is an example of use:\n\n\nfrom hamopy import ham_library as ham\n\nham.cp_liq\nham.p_sat(280)\nham.p_c(0.92, 299)\n\n\n\nThis script first returns the value of the liquid water specific heat, then the water vapor saturation pressure at 280 K, then the capillary pressure at 92 %RH and 299 K.\n\n\nDocumentation main page",
            "title": "Library"
        },
        {
            "location": "/user-guide/library/#library-of-functions",
            "text": "All material-independant values, universal constants and state equations are stored within the  hamopy/ham_library  file. In addition to constant properties such as the latent heat of evaporation, the universal gas constant and the thermal conductivity of air, the file includes 5 useful methods:   p_sat(T) : Water vapor saturation pressure (Pa)  D_va(T) : Water vapor diffusivity in air (m2/s)  p_v(p_c, T) : Water vapor pressure (Pa)  HR(p_c, T) : Relative humidity  p_c(HR, T) : Capillary pressure (Pa)   The last three methods are equivalent formulations of the Clausius-Clapeyron equation. It is used to calculate the relative humidity from values of the capillary pressure, and inversely.  Here is an example of use:  from hamopy import ham_library as ham\n\nham.cp_liq\nham.p_sat(280)\nham.p_c(0.92, 299)  This script first returns the value of the liquid water specific heat, then the water vapor saturation pressure at 280 K, then the capillary pressure at 92 %RH and 299 K.  Documentation main page",
            "title": "Library of functions"
        },
        {
            "location": "/user-guide/post-processing/",
            "text": "Post-processing\n\n\nLet's say you have correctly defined all simulation \ninputs\n and successfully performed a \nsimulation run\n. The last part of your script may look like this:\n\n\nfrom hamopy.algorithm import calcul\n\nresults = calcul(mesh, clim, init, time)\n\n\n\nNow you want to display and analyse some results, which is why you use this program in the first place.\n\n\nSimulation outcome\n\n\nBy default, the main algorithm of hamopy returns a dictionary containing all simulation results and everything one needs to interpret them. Here is a list of all keys and values stored within this dictionary.\n\n\n\n\n'x'\n: Mesh node coordinates; size: \n(N,)\n\n\n't'\n: All time coordinates of the simulation; size: \n(M,)\n\n\n'T'\n: Temperature; size: \n(M,N)\n\n\n'PC'\n: Capillary pressure; size: \n(M,N)\n\n\n'HR'\n: Relative humidity; size: \n(M,N)\n\n\n'PV'\n: Vapor pressure; size: \n(M,N)\n\n\n\n\nAll values are numpy arrays. This is for instance how to read the temperature of the i^th node at the j^th time of simulation:\n\n\nresults['T'][j,i]\n\n\n\nAs this data is a bit raw, two methods are available to easily extract data at user-defined times and locations without having to directly manipulate elements of the \nresults\n dictionary.\n\n\nevolution()\n\n\nThe \nevolution()\n method of the \nhamopy.postpro\n module helps extract the temporal evolution of a variable at a specific location.\n\n\nfrom hamopy.postpro import evolution\nimport numpy as np\n\nx_out = 0.05\nt_out = np.array([0, 60, 120, 180, 240, 300, 360])\nT_out = evolution(results, 'T', x_out, t_out)\n\n\n\nThis example returns the evolution of the temperature over time, at the point given by \nx_out\n, with the temporal discretisation given by \nt_out\n. The function may take 4 input arguments:\n\n\n\n\nthe dictionary of results, provided by the simulation\n\n\na string denoting which variable to extract (it must be one of the keys of \nresults\n)\n\n\nthe location of the point (preferably a single value)\n\n\nthe time scale on which to extract the data (numpy array)\n\n\n\n\nThe last argument is optional: if not given, \nevolution()\n will take all time coordinates in \nresults['t']\n (this is not advised if the simulation time step size was adaptative).\n\n\ndistribution()\n\n\nThe \ndistribution()\n method of the \nhamopy.postpro\n module helps extract the spatial distribution of a variable at a specific time.\n\n\nfrom hamopy.postpro import distribution\nimport numpy as np\n\nx_out  = np.array([0, 0.02, 0.04, 0.06, 0.08, 0.10])\nt_out  = 3600\nHR_out = distribution(results, 'HR', x_out, t_out)\n\n\n\nThis example returns the distribution of relative humidity, at the time given by \nt_out\n, over the spatial discretisation given by \nx_out\n. The function may take 4 input arguments:\n\n\n\n\nthe dictionary of results, provided by the simulation\n\n\na string denoting which variable to extract (it must be one of the keys of \nresults\n)\n\n\nthe coordinates on which the distribution spans (numpy array)\n\n\nthe time of the distribution (preferably a single value)\n\n\n\n\nThe third argument is optional: if not given, \ndistribution()\n will take all mesh node coordinates in \nresults['x']\n.\n\n\nDocumentation main page",
            "title": "Post-processing"
        },
        {
            "location": "/user-guide/post-processing/#post-processing",
            "text": "Let's say you have correctly defined all simulation  inputs  and successfully performed a  simulation run . The last part of your script may look like this:  from hamopy.algorithm import calcul\n\nresults = calcul(mesh, clim, init, time)  Now you want to display and analyse some results, which is why you use this program in the first place.",
            "title": "Post-processing"
        },
        {
            "location": "/user-guide/post-processing/#simulation-outcome",
            "text": "By default, the main algorithm of hamopy returns a dictionary containing all simulation results and everything one needs to interpret them. Here is a list of all keys and values stored within this dictionary.   'x' : Mesh node coordinates; size:  (N,)  't' : All time coordinates of the simulation; size:  (M,)  'T' : Temperature; size:  (M,N)  'PC' : Capillary pressure; size:  (M,N)  'HR' : Relative humidity; size:  (M,N)  'PV' : Vapor pressure; size:  (M,N)   All values are numpy arrays. This is for instance how to read the temperature of the i^th node at the j^th time of simulation:  results['T'][j,i]  As this data is a bit raw, two methods are available to easily extract data at user-defined times and locations without having to directly manipulate elements of the  results  dictionary.",
            "title": "Simulation outcome"
        },
        {
            "location": "/user-guide/post-processing/#evolution",
            "text": "The  evolution()  method of the  hamopy.postpro  module helps extract the temporal evolution of a variable at a specific location.  from hamopy.postpro import evolution\nimport numpy as np\n\nx_out = 0.05\nt_out = np.array([0, 60, 120, 180, 240, 300, 360])\nT_out = evolution(results, 'T', x_out, t_out)  This example returns the evolution of the temperature over time, at the point given by  x_out , with the temporal discretisation given by  t_out . The function may take 4 input arguments:   the dictionary of results, provided by the simulation  a string denoting which variable to extract (it must be one of the keys of  results )  the location of the point (preferably a single value)  the time scale on which to extract the data (numpy array)   The last argument is optional: if not given,  evolution()  will take all time coordinates in  results['t']  (this is not advised if the simulation time step size was adaptative).",
            "title": "evolution()"
        },
        {
            "location": "/user-guide/post-processing/#distribution",
            "text": "The  distribution()  method of the  hamopy.postpro  module helps extract the spatial distribution of a variable at a specific time.  from hamopy.postpro import distribution\nimport numpy as np\n\nx_out  = np.array([0, 0.02, 0.04, 0.06, 0.08, 0.10])\nt_out  = 3600\nHR_out = distribution(results, 'HR', x_out, t_out)  This example returns the distribution of relative humidity, at the time given by  t_out , over the spatial discretisation given by  x_out . The function may take 4 input arguments:   the dictionary of results, provided by the simulation  a string denoting which variable to extract (it must be one of the keys of  results )  the coordinates on which the distribution spans (numpy array)  the time of the distribution (preferably a single value)   The third argument is optional: if not given,  distribution()  will take all mesh node coordinates in  results['x'] .  Documentation main page",
            "title": "distribution()"
        },
        {
            "location": "/examples/Hamstad_BM3/",
            "text": "Hamstad BM3\n\n\nThis script simulates the third exercise of the Hamstad benchmark package: transient heat and moisture transfer impacted by air flow through a lightweight wall.\n\n\nNote that the external air pressure fluctuates on one side of the domain, and that its values are read from a .txt file which has two columns labeled \nTime (s)\n and \nDeltaP\n. This file is available in the \nhamopy/benchmarks\n folder\n\n\nScript\n\n\nfrom hamopy.classes import Mesh, Boundary, Time\n\n# Meshing\nfrom hamopy.materials.hamstad import BM3\n\nmesh = Mesh(**{\"materials\"    : [BM3],\n           \"sizes\"        : [0.2],\n           \"nbr_elements\" : [40] })\n\n# Boundary conditions\nclim_file = 'BM3 climate.txt'\n\nclim1 = Boundary('Fourier',**{\"file\"      : clim_file,\n                          \"time\"      : \"Time (s)\",\n                          \"T\"         : 293.15,\n                          \"HR\"        : 0.7,\n                          \"h_t\"       : 10,\n                          \"h_m\"       : 2e-7,\n                          \"P_air\"     : \"DeltaP\"})\n\nclim2 = Boundary('Fourier',**{\"T\"         : 275.15,\n                          \"HR\"        : 0.8,\n                          \"h_t\"       : 10,\n                          \"h_m\"       : 7.38e-12 })\nclim = [clim1, clim2]\n\n# Initial conditions\ninit = {'T'  : 293.15,\n    'HR' : 0.95}\n\n# Temporal discretisation\ntime = Time('variable',**{\"delta_t\"  : 900,\n                      \"t_max\"    : 8640000,\n                      \"iter_max\" : 12,\n                      \"delta_min\": 1e-3,\n                      \"delta_max\": 900 } )\n\nif __name__ == \"__main__\":\n\n    import numpy  as np\n    import pandas as pd\n\n    # Simulation\n    from hamopy.algorithm import calcul\n    results = calcul(mesh, clim, init, time)\n\n    # Post-processing\n    from hamopy.postpro import evolution\n    data0 = pd.read_csv(clim_file, delimiter='\\t')\n    t_out = np.array( data0['Time (s)'] )\n    x_out = [0.05, 0.1, 0.15, 0.17, 0.19]\n\n    from hamopy import ham_library as ham\n\n    Temperature     = np.column_stack([evolution(results, 'T', _, t_out) for _ in x_out])\n    Humidity        = np.column_stack([evolution(results, 'HR', _, t_out) for _ in x_out])\n    MoistureContent = BM3.w(ham.p_c(Humidity, Temperature), Temperature)\n    # Plotting results\n\n    import matplotlib.pylab as plt\n    from matplotlib import rc\n    rc(\"font\", family=\"serif\", size=12)\n\n    figsize(6, 8)\n\n    ax = plt.subplot(211)\n\n    plt.plot(t_plot / (24*3600), Temperature)\n    plt.xlabel('Time (days)')\n    plt.ylabel('Temperature (C)')\n    plt.legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m'))\n\n    ax = plt.subplot(212)\n\n    plt.plot(t_plot / (24*3600), MoistCont)\n    plt.xlabel('Time (days)')\n    plt.ylabel('Moisture content (kg/m3)')\n    plt.legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m'))\n\n    fig = plt.gcf()\n    fig.savefig('BM3_results.png', format='png', dpi = 300)\n\n\n\nResults",
            "title": "Hamstad BM3"
        },
        {
            "location": "/examples/Hamstad_BM3/#hamstad-bm3",
            "text": "This script simulates the third exercise of the Hamstad benchmark package: transient heat and moisture transfer impacted by air flow through a lightweight wall.  Note that the external air pressure fluctuates on one side of the domain, and that its values are read from a .txt file which has two columns labeled  Time (s)  and  DeltaP . This file is available in the  hamopy/benchmarks  folder",
            "title": "Hamstad BM3"
        },
        {
            "location": "/examples/Hamstad_BM3/#script",
            "text": "from hamopy.classes import Mesh, Boundary, Time\n\n# Meshing\nfrom hamopy.materials.hamstad import BM3\n\nmesh = Mesh(**{\"materials\"    : [BM3],\n           \"sizes\"        : [0.2],\n           \"nbr_elements\" : [40] })\n\n# Boundary conditions\nclim_file = 'BM3 climate.txt'\n\nclim1 = Boundary('Fourier',**{\"file\"      : clim_file,\n                          \"time\"      : \"Time (s)\",\n                          \"T\"         : 293.15,\n                          \"HR\"        : 0.7,\n                          \"h_t\"       : 10,\n                          \"h_m\"       : 2e-7,\n                          \"P_air\"     : \"DeltaP\"})\n\nclim2 = Boundary('Fourier',**{\"T\"         : 275.15,\n                          \"HR\"        : 0.8,\n                          \"h_t\"       : 10,\n                          \"h_m\"       : 7.38e-12 })\nclim = [clim1, clim2]\n\n# Initial conditions\ninit = {'T'  : 293.15,\n    'HR' : 0.95}\n\n# Temporal discretisation\ntime = Time('variable',**{\"delta_t\"  : 900,\n                      \"t_max\"    : 8640000,\n                      \"iter_max\" : 12,\n                      \"delta_min\": 1e-3,\n                      \"delta_max\": 900 } )\n\nif __name__ == \"__main__\":\n\n    import numpy  as np\n    import pandas as pd\n\n    # Simulation\n    from hamopy.algorithm import calcul\n    results = calcul(mesh, clim, init, time)\n\n    # Post-processing\n    from hamopy.postpro import evolution\n    data0 = pd.read_csv(clim_file, delimiter='\\t')\n    t_out = np.array( data0['Time (s)'] )\n    x_out = [0.05, 0.1, 0.15, 0.17, 0.19]\n\n    from hamopy import ham_library as ham\n\n    Temperature     = np.column_stack([evolution(results, 'T', _, t_out) for _ in x_out])\n    Humidity        = np.column_stack([evolution(results, 'HR', _, t_out) for _ in x_out])\n    MoistureContent = BM3.w(ham.p_c(Humidity, Temperature), Temperature)\n    # Plotting results\n\n    import matplotlib.pylab as plt\n    from matplotlib import rc\n    rc(\"font\", family=\"serif\", size=12)\n\n    figsize(6, 8)\n\n    ax = plt.subplot(211)\n\n    plt.plot(t_plot / (24*3600), Temperature)\n    plt.xlabel('Time (days)')\n    plt.ylabel('Temperature (C)')\n    plt.legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m'))\n\n    ax = plt.subplot(212)\n\n    plt.plot(t_plot / (24*3600), MoistCont)\n    plt.xlabel('Time (days)')\n    plt.ylabel('Moisture content (kg/m3)')\n    plt.legend(('x=0.05 m', 'x=0.1 m', 'x=0.15 m', 'x=0.17 m', 'x=0.19 m'))\n\n    fig = plt.gcf()\n    fig.savefig('BM3_results.png', format='png', dpi = 300)",
            "title": "Script"
        },
        {
            "location": "/examples/Hamstad_BM3/#results",
            "text": "",
            "title": "Results"
        },
        {
            "location": "/examples/Hamstad_BM5/",
            "text": "Hamstad BM5\n\n\nThis script simulates the fifth exercise of the Hamstad benchmark package: multi-layered wall with capillary active inside insulation\n\n\nSince hamopy is not really speed-optimised, this may take a few minutes to compute.\n\n\nScript\n\n\n\"\"\"\n5th exercise of the Hamstad benchmark package\n\nCapillary active inside insulation\n\"\"\"\n\nfrom hamopy.classes import Mesh, Boundary, Time\n\n# Choice of materials and geometry\nfrom hamopy.materials.hamstad import BM5_brick, BM5_mortar, BM5_insulation\n\nmesh = Mesh(**{\"materials\"    : [BM5_brick, BM5_mortar, BM5_insulation],\n           \"sizes\"        : [0.365, 0.015, 0.040],\n           \"nbr_elements\" : [100, 20, 20] })\n\n# Boundary conditions\nclim1 = Boundary('Fourier',**{\"T\"   : 273.15,\n                          \"HR\"  : 0.8,\n                          \"h_t\" : 25.,\n                          \"h_m\" : 1.8382e-7 })\n\nclim2 = Boundary('Fourier',**{\"T\"   : 293.15,\n                          \"HR\"  : 0.6,\n                          \"h_t\" : 8.,\n                          \"h_m\" : 5.8823e-8 })\n\nclim = [clim1, clim2]\n\n# Initial conditions\ninit = {'T'  : 298.15,\n    'HR' : 0.6}\n\n# Time step size\ntime = Time('variable',**{\"delta_t\"  : 900,\n                      \"t_max\"    : 12960000,\n                      \"iter_max\" : 12,\n                      \"delta_min\": 1e-3,\n                      \"delta_max\": 900 } )\n\nif __name__ == \"__main__\":\n\n    import numpy as np\n\n    # Calculation\n    from hamopy.algorithm import calcul\n    result = calcul(mesh, clim, init, time)\n\n    # Post processing\n    from hamopy.postpro import distribution\n\n    t_plot = 12960000\n    x_plot = np.linspace(0, 0.42, 421)\n\n    from hamopy import ham_library as ham\n\n    Temperature = distribution(result, 'T', x_plot, t_plot)\n    Humidity    = distribution(result, 'HR', x_plot, t_plot)\n    Moisture    = np.zeros(np.shape(Temperature))\n\n    # Moisture content distribution of each layer\n    for i in range(len(mesh.materials)):\n    xmin = sum(mesh.sizes[0:i])\n    xmax = sum(mesh.sizes[0:i+1])\n    mask = ((x_plot >= xmin) & (x_plot <= xmax))\n    Moisture[mask] = mesh.materials[i].w(ham.p_c(Humidity[mask],Temperature[mask]), Temperature[mask])\n\n    # Plotting results\n\n    import matplotlib.pylab as plt\n    from matplotlib import rc\n    rc(\"font\", family=\"serif\", size=12)\n\n    figsize(6, 8)\n\n    ax = plt.subplot(211)\n\n    plt.plot(x_plot[300:], Humidity[300:], 'k-', linewidth=2)\n    plt.xlabel('x (m)')\n    plt.ylabel('Relative humidity')\n\n    ax = plt.subplot(212)\n\n    plt.plot(x_plot[300:], Moisture[300:], 'k-', linewidth=2)\n    plt.xlabel('x (m)')\n    plt.ylabel('Moisture content (kg/m3)')\n\n    fig = plt.gcf()\n    fig.savefig('BM5_results.png', format='png', dpi = 300)\n\n\n\nResults",
            "title": "Hamstad BM5"
        },
        {
            "location": "/examples/Hamstad_BM5/#hamstad-bm5",
            "text": "This script simulates the fifth exercise of the Hamstad benchmark package: multi-layered wall with capillary active inside insulation  Since hamopy is not really speed-optimised, this may take a few minutes to compute.",
            "title": "Hamstad BM5"
        },
        {
            "location": "/examples/Hamstad_BM5/#script",
            "text": "\"\"\"\n5th exercise of the Hamstad benchmark package\n\nCapillary active inside insulation\n\"\"\"\n\nfrom hamopy.classes import Mesh, Boundary, Time\n\n# Choice of materials and geometry\nfrom hamopy.materials.hamstad import BM5_brick, BM5_mortar, BM5_insulation\n\nmesh = Mesh(**{\"materials\"    : [BM5_brick, BM5_mortar, BM5_insulation],\n           \"sizes\"        : [0.365, 0.015, 0.040],\n           \"nbr_elements\" : [100, 20, 20] })\n\n# Boundary conditions\nclim1 = Boundary('Fourier',**{\"T\"   : 273.15,\n                          \"HR\"  : 0.8,\n                          \"h_t\" : 25.,\n                          \"h_m\" : 1.8382e-7 })\n\nclim2 = Boundary('Fourier',**{\"T\"   : 293.15,\n                          \"HR\"  : 0.6,\n                          \"h_t\" : 8.,\n                          \"h_m\" : 5.8823e-8 })\n\nclim = [clim1, clim2]\n\n# Initial conditions\ninit = {'T'  : 298.15,\n    'HR' : 0.6}\n\n# Time step size\ntime = Time('variable',**{\"delta_t\"  : 900,\n                      \"t_max\"    : 12960000,\n                      \"iter_max\" : 12,\n                      \"delta_min\": 1e-3,\n                      \"delta_max\": 900 } )\n\nif __name__ == \"__main__\":\n\n    import numpy as np\n\n    # Calculation\n    from hamopy.algorithm import calcul\n    result = calcul(mesh, clim, init, time)\n\n    # Post processing\n    from hamopy.postpro import distribution\n\n    t_plot = 12960000\n    x_plot = np.linspace(0, 0.42, 421)\n\n    from hamopy import ham_library as ham\n\n    Temperature = distribution(result, 'T', x_plot, t_plot)\n    Humidity    = distribution(result, 'HR', x_plot, t_plot)\n    Moisture    = np.zeros(np.shape(Temperature))\n\n    # Moisture content distribution of each layer\n    for i in range(len(mesh.materials)):\n    xmin = sum(mesh.sizes[0:i])\n    xmax = sum(mesh.sizes[0:i+1])\n    mask = ((x_plot >= xmin) & (x_plot <= xmax))\n    Moisture[mask] = mesh.materials[i].w(ham.p_c(Humidity[mask],Temperature[mask]), Temperature[mask])\n\n    # Plotting results\n\n    import matplotlib.pylab as plt\n    from matplotlib import rc\n    rc(\"font\", family=\"serif\", size=12)\n\n    figsize(6, 8)\n\n    ax = plt.subplot(211)\n\n    plt.plot(x_plot[300:], Humidity[300:], 'k-', linewidth=2)\n    plt.xlabel('x (m)')\n    plt.ylabel('Relative humidity')\n\n    ax = plt.subplot(212)\n\n    plt.plot(x_plot[300:], Moisture[300:], 'k-', linewidth=2)\n    plt.xlabel('x (m)')\n    plt.ylabel('Moisture content (kg/m3)')\n\n    fig = plt.gcf()\n    fig.savefig('BM5_results.png', format='png', dpi = 300)",
            "title": "Script"
        },
        {
            "location": "/examples/Hamstad_BM5/#results",
            "text": "",
            "title": "Results"
        },
        {
            "location": "/about/author/",
            "text": "Hamopy is maintained by Simon Rouchier, researcher at the \nUniversit\u00e9 Savoie Mont-Blanc\n.\n\n\nThe hamopy package is hosted on \nGitHub\n\n\nYou can also check out my website here for other projects I am working on: \nhttps://simonrouchier.wordpress.com/",
            "title": "Author"
        },
        {
            "location": "/about/license/",
            "text": "GNU LESSER GENERAL PUBLIC LICENSE\n                   Version 3, 29 June 2007\n\n\n\nCopyright (C) 2007 Free Software Foundation, Inc. \nhttp://fsf.org/\n\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\nThis version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n\n\n\nAdditional Definitions.\n\n\n\n\nAs used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n\n\"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n\nAn \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n\nA \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n\nThe \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n\nThe \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n\n\n\nException to Section 3 of the GNU GPL.\n\n\n\n\nYou may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n\n\n\nConveying Modified Versions.\n\n\n\n\nIf you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n\na) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n\nb) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n\n\n\nObject Code Incorporating Material from Library Header Files.\n\n\n\n\nThe object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n\na) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n\nb) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n\n\n\nCombined Works.\n\n\n\n\nYou may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n\na) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n\nb) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n\nc) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n\nd) Do one of the following:\n\n\n0) Convey the Minimal Corresponding Source under the terms of this\n   License, and the Corresponding Application Code in a form\n   suitable for, and under terms that permit, the user to\n   recombine or relink the Application with a modified version of\n   the Linked Version to produce a modified Combined Work, in the\n   manner specified by section 6 of the GNU GPL for conveying\n   Corresponding Source.\n\n\n1) Use a suitable shared library mechanism for linking with the\n   Library.  A suitable mechanism is one that (a) uses at run time\n   a copy of the Library already present on the user's computer\n   system, and (b) will operate properly with a modified version\n   of the Library that is interface-compatible with the Linked\n   Version.\n\n\ne) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n\n\n\nCombined Libraries.\n\n\n\n\nYou may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n\na) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n\nb) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n\n\n\nRevised Versions of the GNU Lesser General Public License.\n\n\n\n\nThe Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n\nEach version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n\nIf the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.",
            "title": "License"
        }
    ]
}